<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Collaborative PDF Page Finder</title>
    
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- PDF.js for rendering PDFs -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.min.js"></script>
    <script>
        pdfjsLib.GlobalWorkerOptions.workerSrc = `https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.worker.min.js`;
    </script>
    
    <!-- PDF-Lib for creating new PDFs -->
    <script src="https://unpkg.com/pdf-lib@1.17.1/dist/pdf-lib.min.js"></script>
    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">

    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f1f5f9; /* slate-100 */
        }
        .page-canvas {
            border: 1px solid #cbd5e1; /* slate-300 */
            border-radius: 0.5rem;
            box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
        }
        .page-wrapper {
            position: relative;
            padding-top: 1.5rem;
        }
        .remove-page-btn {
            position: absolute;
            top: 0;
            right: 0;
        }
        /* Custom styles for notifications and modals */
        #notification-container {
            position: fixed;
            top: 1.5rem;
            right: 1.5rem;
            z-index: 100;
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }
        .notification {
            padding: 1rem 1.5rem;
            border-radius: 0.5rem;
            color: white;
            font-weight: 600;
            box-shadow: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
            transform: translateX(120%);
            transition: transform 0.3s ease-in-out;
        }
        .notification.show {
            transform: translateX(0);
        }
        .notification.success { background-color: #16a34a; /* green-600 */ }
        .notification.error { background-color: #dc2626; /* red-600 */ }

        /* Styles for the magnifier popover */
        #magnifier-popover {
            position: fixed;
            z-index: 200;
            background-color: white;
            border: 1px solid #94a3b8; /* slate-400 */
            border-radius: 0.5rem;
            box-shadow: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
            pointer-events: none;
            padding: 0.5rem;
        }

        #magnifier-popover canvas {
            display: block;
        }

        /* Styles for the Index Parser Modal */
        #index-canvas-wrapper {
            display: flex;
            align-items: flex-start; 
        }
        #index-parser-canvas {
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            border: 1px solid #ccc;
            cursor: crosshair;
        }
        
        /* Drag and Drop Area Styling */
        .dragover {
            border-color: #3b82f6; /* blue-500 */
            background-color: #eff6ff; /* blue-50 */
        }
    </style>
</head>
<body class="text-slate-800">
    <!-- Main Application Container -->
    <div class="container mx-auto p-4 md:p-8 max-w-4xl">

        <header class="bg-white p-6 rounded-lg shadow-md mb-8">
            <h1 class="text-3xl font-bold text-slate-700">Collaborative PDF Page Finder</h1>
            <p class="text-slate-500 mt-1">Find pages and manage shared search groups in real-time.</p>
        </header>

        <!-- Control Panel -->
        <div class="bg-white p-6 rounded-lg shadow-md mb-8">
            <!-- 1. PDF File Input -->
            <div class="mb-6">
                <label class="block text-lg font-semibold text-slate-600 mb-2">1. Open a PDF File</label>
                
                <!-- Drag and Drop Zone -->
                <div id="drop-zone" class="border-2 border-dashed border-slate-300 rounded-lg p-8 text-center cursor-pointer hover:border-blue-500 transition-colors">
                    <div class="flex flex-col items-center justify-center pointer-events-none">
                        <svg class="w-12 h-12 text-slate-400 mb-4" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" d="M19.5 14.25v-2.625a3.375 3.375 0 0 0-3.375-3.375h-1.5A1.125 1.125 0 0 1 13.5 7.125v-1.5a3.375 3.375 0 0 0-3.375-3.375H8.25m.75 12 3 3m0 0 3-3m-3 3v-6m-1.5-9H5.625c-.621 0-1.125.504-1.125 1.125v17.25c0 .621.504 1.125 1.125 1.125h12.75c.621 0 1.125-.504 1.125-1.125V11.25a9 9 0 0 0-9-9Z" />
                        </svg>
                        <p class="text-slate-500">Drag & drop your PDF here, or</p>
                        <span class="mt-2 text-blue-600 font-semibold hover:underline pointer-events-auto">click to select a file</span>
                        <input type="file" id="file-input" class="hidden" accept="application/pdf">
                    </div>
                </div>

                <div id="file-info" class="mt-2 text-sm text-slate-600">No file selected.</div>
                <div class="mt-4">
                    <button id="parse-index-btn" class="hidden bg-indigo-500 text-white font-semibold py-2 px-4 rounded-lg hover:bg-indigo-600 transition duration-300 disabled:bg-slate-400 disabled:cursor-not-allowed">
                        Select & Parse Index
                    </button>
                </div>
            </div>

            <!-- 2. Search Terms Input -->
            <div class="mb-4">
                <label for="search-terms-input" class="block text-lg font-semibold text-slate-600 mb-2">2. Enter Search Terms</label>
                <textarea id="search-terms-input" rows="3" class="w-full p-3 border border-slate-300 rounded-md focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition" placeholder="e.g. P.001, P.002, PIPE LEGEND"></textarea>
                <p class="text-xs text-slate-500 mt-1">Separate each search term with a comma.</p>
            </div>
            
            <!-- 3. Collaborative Search Groups -->
            <div class="border-t border-slate-200 pt-4 mt-6">
                 <label class="block text-lg font-semibold text-slate-600 mb-2">3. Manage Shared Search Groups</label>
                 <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                      <div>
                           <label for="search-groups-dropdown" class="text-sm font-medium text-slate-600">Load a saved group:</label>
                           <div class="flex items-center space-x-2 mt-1">
                                <select id="search-groups-dropdown" class="w-full p-2 border border-slate-300 rounded-md bg-white"></select>
                                <button id="load-group-btn" title="Load Selected Group" class="p-2 bg-slate-200 hover:bg-slate-300 rounded-md">
                                     <svg class="w-5 h-5" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M8.25 6.75 12 3m0 0 3.75 3.75M12 3v18" /></svg>
                                </button>
                                <button id="delete-group-btn" title="Delete Selected Group" class="p-2 bg-red-100 hover:bg-red-200 text-red-600 rounded-md"><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path></svg></button>
                           </div>
                      </div>
                      <div>
                           <label for="new-group-name" class="text-sm font-medium text-slate-600">Save current search as a group:</label>
                           <div class="flex items-center space-x-2 mt-1">
                                <input type="text" id="new-group-name" placeholder="Group Name" class="w-full p-2 border border-slate-300 rounded-md">
                                <button id="save-group-btn" title="Save Current Terms" class="p-2 bg-green-500 hover:bg-green-600 text-white rounded-md"><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7H5a2 2 0 00-2 2v9a2 2 0 002 2h14a2 2 0 002-2V9a2 2 0 00-2-2h-3m-1 4l-3 3m0 0l-3-3m3 3V4"></path></svg></button>
                           </div>
                      </div>
                 </div>
            </div>

            <!-- 4. Run Search -->
            <div class="mt-6 border-t pt-6">
                <button id="run-search-btn" class="w-full bg-blue-600 text-white font-bold py-3 px-4 rounded-lg hover:bg-blue-700 transition duration-300 flex items-center justify-center text-lg disabled:bg-slate-400 disabled:cursor-not-allowed">
                    <svg class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"></path></svg>
                    Find Pages
                </button>
            </div>
        </div>

        <!-- Parsed Index Section (Initially Hidden) -->
        <div id="parsed-index-container" class="hidden bg-white p-6 rounded-lg shadow-md mb-8">
            <div class="flex justify-between items-center border-b pb-3 mb-4">
                <h2 class="text-2xl font-bold text-slate-700">Parsed Index</h2>
                <button id="add-selected-index-btn" class="bg-blue-600 text-white font-semibold py-2 px-4 rounded-lg hover:bg-blue-700 transition duration-300 flex items-center">
                    Add Selected to Results
                </button>
            </div>
            <div id="parsed-index-output" class="space-y-2 max-h-96 overflow-y-auto">
                <p class="text-slate-500">Select an area from the PDF to parse an index.</p>
            </div>
        </div>

        <!-- Results Section -->
        <div id="results-container" class="bg-white p-6 rounded-lg shadow-md">
             <div class="flex justify-between items-center border-b pb-3 mb-4">
                   <h2 class="text-2xl font-bold text-slate-700">Results</h2>
                   <button id="open-pdf-btn" class="hidden bg-green-600 text-white font-semibold py-2 px-4 rounded-lg hover:bg-green-700 transition duration-300 flex items-center">
                       <svg class="w-5 h-5 mr-2" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M13.5 6H5.25A2.25 2.25 0 0 0 3 8.25v10.5A2.25 2.25 0 0 0 5.25 21h10.5A2.25 2.25 0 0 0 18 18.75V10.5m-10.5 6L21 3m0 0h-5.25M21 3v5.25" /></svg>
                       Open Filtered PDF
                   </button>
             </div>
              <div id="results-summary"></div>
              <!-- Page Adders -->
              <div id="page-adders-container" class="hidden mt-4 pt-4 border-t border-slate-200 grid grid-cols-1 md:grid-cols-2 gap-x-8 gap-y-4">
               <div>
                    <h3 class="text-lg font-semibold text-slate-600 mb-2">Add a Range</h3>
                    <div class="flex items-center space-x-2">
                         <input type="number" id="range-start-input" placeholder="Start" class="w-full p-2 border border-slate-300 rounded-md">
                         <span class="text-slate-500 font-bold">-</span>
                         <input type="number" id="range-end-input" placeholder="End" class="w-full p-2 border border-slate-300 rounded-md">
                         <button id="add-range-btn" class="p-2 bg-blue-500 hover:bg-blue-600 text-white rounded-md font-semibold px-4">Add</button>
                    </div>
               </div>
               <div>
                    <h3 class="text-lg font-semibold text-slate-600 mb-2">Add a Page</h3>
                    <div class="flex items-center space-x-2">
                         <input type="number" id="add-page-input" placeholder="Page #" class="w-full p-2 border border-slate-300 rounded-md">
                         <button id="add-page-btn" class="p-2 bg-blue-500 hover:bg-blue-600 text-white rounded-md font-semibold px-4">Add</button>
                    </div>
               </div>
              </div>
              <div id="results-output" class="flex overflow-x-auto space-x-6 p-4 bg-slate-50 rounded-lg mt-6">
                   <p class="w-full px-2 col-span-full">Search results will appear here.</p>
              </div>
        </div>
    </div>
    
    <!-- UI Overlays: Loading, Confirmation, Notifications, Index Parser -->
    <div id="loading-modal" class="hidden fixed inset-0 bg-gray-800 bg-opacity-75 flex items-center justify-center z-50">
        <div class="bg-white p-5 rounded-lg flex items-center shadow-xl">
            <svg class="w-8 h-8 animate-spin text-blue-600 mr-4" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg>
            <span id="loading-text" class="text-lg font-medium text-gray-700">Searching...</span>
        </div>
    </div>

    <div id="notification-container"></div>

    <div id="confirmation-modal" class="hidden fixed inset-0 bg-gray-800 bg-opacity-75 flex items-center justify-center z-50">
        <div class="bg-white p-6 rounded-lg shadow-xl w-full max-w-sm">
            <h3 id="confirmation-title" class="text-lg font-bold text-slate-800 mb-4">Are you sure?</h3>
            <div class="flex justify-end space-x-3">
                <button id="confirm-btn-no" class="px-4 py-2 bg-slate-200 hover:bg-slate-300 rounded-md font-semibold">No</button>
                <button id="confirm-btn-yes" class="px-4 py-2 bg-red-600 text-white hover:bg-red-700 rounded-md font-semibold">Yes</button>
            </div>
        </div>
    </div>

    <div id="index-parser-modal" class="hidden fixed inset-0 bg-gray-800 bg-opacity-75 flex flex-col items-center justify-center z-[60] p-4">
        <div class="bg-white rounded-lg shadow-xl w-full max-w-6xl h-full flex flex-col">
            <!-- Header -->
            <div class="p-4 border-b flex justify-between items-center flex-shrink-0">
                <h3 class="text-xl font-bold text-slate-800">Select Index Area</h3>
                <div class="flex items-center space-x-4 flex-wrap">
                    <div class="flex items-center space-x-2">
                        <button id="index-prev-page" class="p-2 bg-slate-200 hover:bg-slate-300 rounded-md">&lt;</button>
                        <span>Page <input type="number" id="index-page-num" class="w-16 text-center border rounded-md p-1"> of <span id="index-page-count">0</span></span>
                        <button id="index-next-page" class="p-2 bg-slate-200 hover:bg-slate-300 rounded-md">&gt;</button>
                    </div>
                    <div class="flex items-center space-x-2">
                        <button id="zoom-out-btn" title="Zoom Out" class="p-2 bg-slate-200 hover:bg-slate-300 rounded-md">
                            <svg class="w-5 h-5" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M21 21l-5.197-5.197m0 0A7.5 7.5 0 105.196 5.196a7.5 7.5 0 0010.607 10.607zM13.5 10.5h-6" /></svg>
                        </button>
                        <span id="zoom-display" class="font-mono text-sm text-slate-600 w-12 text-center">100%</span>
                        <button id="zoom-in-btn" title="Zoom In" class="p-2 bg-slate-200 hover:bg-slate-300 rounded-md">
                            <svg class="w-5 h-5" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M21 21l-5.197-5.197m0 0A7.5 7.5 0 105.196 5.196a7.5 7.5 0 0010.607 10.607zM10.5 7.5v6m3-3h-6" /></svg>
                        </button>
                        <button id="zoom-fit-btn" title="Fit to Width" class="p-2 bg-slate-200 hover:bg-slate-300 rounded-md">
                            <svg class="w-5 h-5" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M3.75 3.75v4.5m0-4.5h4.5m-4.5 0L9 9M20.25 20.25v-4.5m0 4.5h-4.5m4.5 0L15 15" /></svg>
                        </button>
                    </div>
                    <button id="parse-selection-btn" class="px-4 py-2 bg-green-600 text-white hover:bg-green-700 rounded-md font-semibold disabled:bg-slate-400" disabled>Parse Selection</button>
                    <button id="cancel-index-parser-btn" class="px-4 py-2 bg-slate-200 hover:bg-slate-300 rounded-md font-semibold">Cancel</button>
                </div>
            </div>
            <!-- Content -->
            <div id="index-canvas-wrapper" class="flex-grow p-4 overflow-auto bg-slate-100 relative">
                <div class="relative"> <!-- Added a relative container for canvas and selection box -->
                    <canvas id="index-parser-canvas"></canvas>
                    <div id="selection-box" class="absolute border-2 border-dashed border-blue-500 bg-blue-500 bg-opacity-20 pointer-events-none" style="display: none;"></div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Main Application Logic -->
    <script type="module">
        // Import Firebase modules
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, collection, onSnapshot, addDoc, doc, deleteDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // --- DOM Element References ---
        const fileInput = document.getElementById('file-input');
        const dropZone = document.getElementById('drop-zone');
        const fileInfo = document.getElementById('file-info');
        const searchTermsInput = document.getElementById('search-terms-input');
        const runSearchBtn = document.getElementById('run-search-btn');
        const resultsSummary = document.getElementById('results-summary');
        const resultsOutput = document.getElementById('results-output');
        const openPdfBtn = document.getElementById('open-pdf-btn');
        const loadingModal = document.getElementById('loading-modal');
        const loadingText = document.getElementById('loading-text');
        const searchGroupsDropdown = document.getElementById('search-groups-dropdown');
        const newGroupNameInput = document.getElementById('new-group-name');
        const saveGroupBtn = document.getElementById('save-group-btn');
        const loadGroupBtn = document.getElementById('load-group-btn');
        const deleteGroupBtn = document.getElementById('delete-group-btn');
        const pageAddersContainer = document.getElementById('page-adders-container');
        const rangeStartInput = document.getElementById('range-start-input');
        const rangeEndInput = document.getElementById('range-end-input');
        const addRangeBtn = document.getElementById('add-range-btn');
        const addPageInput = document.getElementById('add-page-input');
        const addPageBtn = document.getElementById('add-page-btn');
        const notificationContainer = document.getElementById('notification-container');
        const confirmationModal = document.getElementById('confirmation-modal');
        const confirmationTitle = document.getElementById('confirmation-title');
        const confirmBtnYes = document.getElementById('confirm-btn-yes');
        const confirmBtnNo = document.getElementById('confirm-btn-no');
        
        // Index Parser DOM Elements
        const parseIndexBtn = document.getElementById('parse-index-btn');
        const indexParserModal = document.getElementById('index-parser-modal');
        const indexCanvasWrapper = document.getElementById('index-canvas-wrapper');
        const indexParserCanvas = document.getElementById('index-parser-canvas');
        const selectionBox = document.getElementById('selection-box');
        const indexPrevPageBtn = document.getElementById('index-prev-page');
        const indexNextPageBtn = document.getElementById('index-next-page');
        const indexPageNumInput = document.getElementById('index-page-num');
        const indexPageCount = document.getElementById('index-page-count');
        const parseSelectionBtn = document.getElementById('parse-selection-btn');
        const cancelIndexParserBtn = document.getElementById('cancel-index-parser-btn');
        const parsedIndexContainer = document.getElementById('parsed-index-container');
        const parsedIndexOutput = document.getElementById('parsed-index-output');
        const addSelectedIndexBtn = document.getElementById('add-selected-index-btn');
        const zoomOutBtn = document.getElementById('zoom-out-btn');
        const zoomInBtn = document.getElementById('zoom-in-btn');
        const zoomFitBtn = document.getElementById('zoom-fit-btn');
        const zoomDisplay = document.getElementById('zoom-display');


        // --- Application State ---
        let currentPdf = null;
        let matchedPageNumbers = [];
        let searchGroups = [];
        let db, auth, userId;
        let isAuthReady = false;
        let groupsCollectionRef;
        const appId = 'pdf-search-tool-v1'; // Static App ID for the live site

        // Index Parser State
        let indexParserState = {
            pdf: null,
            currentPageNum: 1,
            totalPages: 0,
            isSelecting: false,
            selectionStart: { x: 0, y: 0 },
            selectionRect: { x: 0, y: 0, w: 0, h: 0 },
            currentRenderedPage: null,
            currentViewport: null,
            currentScale: 'auto', // 'auto' or a number
        };

        // --- Firebase Initialization ---
        async function initializeFirebase() {
            try {
                // Hardcoded Firebase config from the working script
                const firebaseConfig = {
                    apiKey: "AIzaSyBu50nNfswe73_JC96yB2wYPqiB1jqR1vw",
                    authDomain: "pdf-search-tool-live.firebaseapp.com",
                    projectId: "pdf-search-tool-live",
                    storageBucket: "pdf-search-tool-live.appspot.com",
                    messagingSenderId: "976932655448",
                    appId: "1:976932655448:web:f7fe06ecc9aa3d1c5f552d",
                    measurementId: "G-W9GPTLHY9V"
                };

                const app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                auth = getAuth(app);
                
                groupsCollectionRef = collection(db, `/artifacts/${appId}/public/data/searchGroups`);

                onAuthStateChanged(auth, async (user) => {
                    if (user) {
                        userId = user.uid;
                        isAuthReady = true;
                        console.log("Authenticated with UID:", userId);
                        loadGroupsFromFirestore();
                    } else {
                        console.log("User not signed in.");
                        isAuthReady = false;
                    }
                });

                await signInAnonymously(auth);

            } catch (error) {
                console.error("Firebase initialization failed:", error);
                showNotification("Could not connect to the collaborative service.", "error");
            }
        }
        
        // --- Core Application Logic ---

        async function loadFile(file) {
            runSearchBtn.disabled = true;
            parseIndexBtn.classList.add('hidden');

            if (!file || file.type !== 'application/pdf') {
                showNotification('Please select a valid PDF file.', 'error');
                fileInfo.textContent = 'Please select a valid PDF file.';
                currentPdf = null;
                return;
            }
            fileInfo.textContent = `File: ${file.name}`;
            const fileReader = new FileReader();
            fileReader.onload = async (e) => {
                setLoading(true, "Loading PDF...");
                try {
                    const typedarray = new Uint8Array(e.target.result);
                    currentPdf = await pdfjsLib.getDocument({ data: typedarray }).promise;
                    console.log("loadFile: PDF loaded successfully. currentPdf object:", currentPdf);
                    runSearchBtn.disabled = false;
                    parseIndexBtn.classList.remove('hidden');
                } catch (error) {
                    console.error("loadFile: Error loading PDF:", error);
                    fileInfo.textContent = 'Error: Could not load PDF. Check console for details.';
                    showNotification('Error: Could not load PDF.', 'error');
                    currentPdf = null;
                } finally {
                    setLoading(false);
                }
            };
            fileReader.readAsArrayBuffer(file);
        }

        function handleFileSelect(event) {
            const file = event.target.files[0];
            if (file) {
                loadFile(file);
            }
        }

        async function runSearch() {
            console.log("runSearch: Fired. Checking currentPdf:", currentPdf);
            if (!currentPdf) {
                showNotification('Please select a PDF file first.', 'error');
                return;
            }
            const termsText = searchTermsInput.value.trim();
            if (!termsText) {
                showNotification('Please enter some search terms.', 'error');
                return;
            }
            
            const searchTerms = termsText.split(',').map(term => term.trim().toLowerCase().replace(/\s+/g, '')).filter(term => term.length > 0);
            
            if (searchTerms.length === 0) {
                showNotification('Please enter valid search terms.', 'error');
                return;
            }

            setLoading(true, "Searching PDF...");
            resultsOutput.innerHTML = ''; 
            resultsSummary.innerHTML = '';
            openPdfBtn.classList.add('hidden'); 
            pageAddersContainer.classList.add('hidden'); 
            const matchedPages = new Set(); 

            for (let i = 1; i <= currentPdf.numPages; i++) {
                setLoading(true, `Searching page ${i} of ${currentPdf.numPages}...`);
                const page = await currentPdf.getPage(i);
                const textContent = await page.getTextContent();
                const pageText = textContent.items.map(item => item.str).join('').toLowerCase().replace(/\s+/g, '');

                const isMatch = searchTerms.some(term => pageText.includes(term));
                if (isMatch) {
                    matchedPages.add(page.pageNumber); 
                }
            }

            matchedPageNumbers = Array.from(matchedPages).sort((a,b) => a-b);
            await rerenderAllResults();
            updateResultsSummary();
            setLoading(false);
        }
        
        async function openFilteredPdfInNewTab() {
            if (!fileInput.files[0] || matchedPageNumbers.length === 0) {
                showNotification("No file or pages to open.", "error");
                return;
            }
            
            setLoading(true, "Creating new PDF...");
            try {
                const originalPdfBytes = await fileInput.files[0].arrayBuffer();
                const { PDFDocument } = PDFLib; 
                const pdfDoc = await PDFDocument.load(originalPdfBytes);
                const newPdfDoc = await PDFDocument.create();

                const pageIndices = matchedPageNumbers.map(n => n - 1).sort((a, b) => a - b);
                const copiedPages = await newPdfDoc.copyPages(pdfDoc, pageIndices);
                copiedPages.forEach(page => newPdfDoc.addPage(page));

                const newPdfBytes = await newPdfDoc.save();
                const blob = new Blob([newPdfBytes], { type: 'application/pdf' });
                const blobUrl = URL.createObjectURL(blob);
                window.open(blobUrl, '_blank');
            } catch (error) {
                console.error("Error creating filtered PDF:", error);
                showNotification("Error creating PDF. Check console.", "error");
            } finally {
                setLoading(false);
            }
        }
        
        // --- UI Rendering Functions ---

        async function renderPage(page, container) {
            const pageNum = page.pageNumber;
            const wrapper = document.createElement('div');
            wrapper.className = 'page-wrapper flex-shrink-0 w-64';
            wrapper.id = `page-wrapper-${pageNum}`;

            // Store the page number directly on the element for easy access later.
            wrapper.dataset.pageNumber = pageNum;

            const removeBtn = document.createElement('button');
            removeBtn.innerHTML = '&times;';
            removeBtn.className = 'remove-page-btn bg-red-500 text-white rounded-full w-6 h-6 flex items-center justify-center font-bold hover:bg-red-700 transition-colors z-10';
            removeBtn.title = `Remove page ${pageNum}`;
            removeBtn.onclick = () => removePage(pageNum);
            
            const unscaledViewport = page.getViewport({ scale: 1.0 });
            const containerWidth = 256; // w-64 is 256px
            const scale = (containerWidth / unscaledViewport.width); 
            const viewport = page.getViewport({ scale: scale });

            const canvas = document.createElement('canvas');
            canvas.className = 'page-canvas mx-auto'; 
            const context = canvas.getContext('2d');
            canvas.height = viewport.height;
            canvas.width = viewport.width;

            const pageTitle = document.createElement('p');
            pageTitle.className = 'text-sm font-bold text-center text-slate-600 mb-1';
            pageTitle.textContent = `Page ${pageNum}`;

            // Add event listeners for the magnifier popover
            wrapper.addEventListener('mouseenter', handleMouseEnter);
            wrapper.addEventListener('mouseleave', handleMouseLeave);
            
            wrapper.appendChild(removeBtn); 
            wrapper.appendChild(pageTitle); 
            wrapper.appendChild(canvas);
            container.appendChild(wrapper);

            await page.render({ canvasContext: context, viewport: viewport }).promise;
        }

        async function rerenderAllResults() {
            resultsOutput.innerHTML = '<p class="w-full px-2">Loading page previews...</p>'; 
            if (matchedPageNumbers.length > 0) {
                resultsOutput.innerHTML = '';
                 for (const pageNum of matchedPageNumbers) {
                      const page = await currentPdf.getPage(pageNum);
                      await renderPage(page, resultsOutput);
                 }
            } else {
                 resultsOutput.innerHTML = '<p class="w-full px-2">No pages found or all pages have been removed.</p>';
            }
        }

        function removePage(pageNum) {
            const wrapperToRemove = document.getElementById(`page-wrapper-${pageNum}`);
            if (wrapperToRemove) wrapperToRemove.remove();
            matchedPageNumbers = matchedPageNumbers.filter(num => num !== pageNum);
            updateResultsSummary();
        }

        function updateResultsSummary() {
            if (matchedPageNumbers.length > 0) {
                 const pageNumbersList = matchedPageNumbers.sort((a, b) => a - b);
                 resultsSummary.innerHTML = `<p class="mb-2 font-semibold">${matchedPageNumbers.length} selected page(s).</p><div class="mb-2 text-sm text-slate-600 break-words">Pages: <strong>${pageNumbersList.join(', ')}</strong></div>`;
                 openPdfBtn.classList.remove('hidden');
                 pageAddersContainer.classList.remove('hidden'); 
            } else {
                 resultsSummary.innerHTML = '';
                 openPdfBtn.classList.add('hidden');
                 pageAddersContainer.classList.add('hidden');
                 resultsOutput.innerHTML = '<p class="w-full px-2">No pages found or all pages have been removed.</p>';
            }
        }
        
        // --- Page Adding Functions ---

        async function handleAddRange() {
            if (!currentPdf) return showNotification("Please load a PDF first.", "error");
            const start = parseInt(rangeStartInput.value, 10);
            const end = parseInt(rangeEndInput.value, 10);

            if (isNaN(start) || isNaN(end) || start > end) return showNotification("Invalid page range.", "error");
            if (start < 1 || end > currentPdf.numPages) return showNotification(`Pages must be between 1 and ${currentPdf.numPages}.`, "error");

            setLoading(true, "Adding page range...");
            const pagesToInclude = new Set(matchedPageNumbers);
            for (let i = start; i <= end; i++) pagesToInclude.add(i);
            matchedPageNumbers = Array.from(pagesToInclude).sort((a, b) => a - b);
            
            await rerenderAllResults();
            updateResultsSummary();
            rangeStartInput.value = '';
            rangeEndInput.value = '';
            setLoading(false);
        }
        
        async function handleAddSinglePage() {
            if (!currentPdf) return showNotification("Please load a PDF first.", "error");
            const pageNum = parseInt(addPageInput.value, 10);

            if (isNaN(pageNum)) return showNotification("Please enter a valid page number.", "error");
            if (pageNum < 1 || pageNum > currentPdf.numPages) return showNotification(`Page must be between 1 and ${currentPdf.numPages}.`, "error");

            setLoading(true, `Adding page ${pageNum}...`);
            const pagesToInclude = new Set(matchedPageNumbers);
            pagesToInclude.add(pageNum);
            matchedPageNumbers = Array.from(pagesToInclude).sort((a, b) => a - b);
            
            await rerenderAllResults();
            updateResultsSummary();
            addPageInput.value = '';
            setLoading(false);
        }

        // --- Search Group Functions (Firestore) ---

        function loadGroupsFromFirestore() {
            if (!isAuthReady) return;
            onSnapshot(groupsCollectionRef, (snapshot) => {
                searchGroups = snapshot.docs.map(doc => ({ ...doc.data(), id: doc.id }));
                renderSearchGroupsDropdown();
            }, (error) => {
                console.error("Error listening to group changes: ", error);
                showNotification("Could not load shared groups.", "error");
            });
        }

        async function saveSearchGroup() {
            if (!isAuthReady) return showNotification("Not connected to collaborative service.", "error");
            const name = newGroupNameInput.value.trim();
            const terms = searchTermsInput.value.trim();
            if (!name) return showNotification("Please enter a name for the group.", "error");
            if (!terms) return showNotification("Please enter search terms to save.", "error");

            try {
                await addDoc(groupsCollectionRef, { name, terms });
                newGroupNameInput.value = '';
                showNotification(`Group "${name}" saved.`, "success");
            } catch (error) {
                console.error("Error saving group:", error);
                showNotification("Could not save group.", "error");
            }
        }

        function loadSearchGroup() {
            const selectedId = searchGroupsDropdown.value;
            const selectedGroup = searchGroups.find(g => g.id === selectedId);
            if (selectedGroup) {
                searchTermsInput.value = selectedGroup.terms;
            }
        }

        async function deleteSearchGroup() {
            if (!isAuthReady) return showNotification("Not connected to collaborative service.", "error");
            const selectedId = searchGroupsDropdown.value;
            if (!selectedId) return;

            const selectedGroup = searchGroups.find(g => g.id === selectedId);

            showConfirmation(`Delete the group "${selectedGroup.name}"?`, async () => {
                try {
                    const docRef = doc(db, `/artifacts/${appId}/public/data/searchGroups/${selectedId}`);
                    await deleteDoc(docRef);
                    showNotification(`Group "${selectedGroup.name}" deleted.`, "success");
                } catch (error) {
                    console.error("Error deleting group: ", error);
                    showNotification("Could not delete group.", "error");
                }
            });
        }
        
        function renderSearchGroupsDropdown() {
            const selectedValue = searchGroupsDropdown.value;
            searchGroupsDropdown.innerHTML = '<option value="">-- Select a Group --</option>';
            const sortedGroups = [...searchGroups].sort((a, b) => a.name.localeCompare(b.name));
            for (const group of sortedGroups) {
                const option = document.createElement('option');
                option.value = group.id;
                option.textContent = group.name;
                searchGroupsDropdown.appendChild(option);
            }
            searchGroupsDropdown.value = selectedValue;
        }

        // --- Index Parser Functions ---

        function openIndexParser() {
            if (!currentPdf) return;
            indexParserState.pdf = currentPdf;
            indexParserState.totalPages = currentPdf.numPages;
            indexParserState.currentPageNum = 1;
            indexParserState.currentScale = 'auto'; // Reset zoom on open
            indexPageCount.textContent = indexParserState.totalPages;
            indexPageNumInput.value = 1;
            indexParserModal.classList.remove('hidden');
            renderIndexPage(1);
        }

        function closeIndexParser() {
            indexParserModal.classList.add('hidden');
            // Clear canvas to free memory
            indexParserCanvas.width = 0;
            indexParserCanvas.height = 0;
            selectionBox.style.display = 'none';
            parseSelectionBtn.disabled = true;
        }

        async function renderIndexPage(pageNum) {
            if (!indexParserState.pdf) return;
            setLoading(true, `Loading page ${pageNum}...`);
            try {
                const page = await indexParserState.pdf.getPage(pageNum);
                indexParserState.currentRenderedPage = page;
                
                let scale;
                const unscaledViewport = page.getViewport({ scale: 1.0 });

                if (indexParserState.currentScale === 'auto') {
                    const wrapperWidth = indexCanvasWrapper.clientWidth - 40; // Subtract padding
                    scale = wrapperWidth / unscaledViewport.width;
                } else {
                    scale = indexParserState.currentScale;
                }

                zoomDisplay.textContent = `${Math.round(scale * 100)}%`;
                const viewport = page.getViewport({ scale: scale });
                indexParserState.currentViewport = viewport;

                const context = indexParserCanvas.getContext('2d');
                indexParserCanvas.height = viewport.height;
                indexParserCanvas.width = viewport.width;

                await page.render({ canvasContext: context, viewport: viewport }).promise;
            } catch (error) {
                console.error(`Failed to render page ${pageNum}:`, error);
                showNotification(`Could not render page ${pageNum}.`, 'error');
            } finally {
                setLoading(false);
            }
        }
        
        function changeIndexPage(delta) {
            let newPageNum = indexParserState.currentPageNum + delta;
            if (newPageNum > 0 && newPageNum <= indexParserState.totalPages) {
                indexParserState.currentPageNum = newPageNum;
                indexPageNumInput.value = newPageNum;
                renderIndexPage(newPageNum);
            }
        }

        function goToIndexPage() {
            let newPageNum = parseInt(indexPageNumInput.value, 10);
            if (!isNaN(newPageNum) && newPageNum > 0 && newPageNum <= indexParserState.totalPages) {
                indexParserState.currentPageNum = newPageNum;
                renderIndexPage(newPageNum);
            } else {
                indexPageNumInput.value = indexParserState.currentPageNum; // Reset to valid
            }
        }

        function handleSelectionStart(e) {
            indexParserState.isSelecting = true;
            indexParserState.selectionStart.x = e.offsetX;
            indexParserState.selectionStart.y = e.offsetY;
            selectionBox.style.left = `${e.offsetX}px`;
            selectionBox.style.top = `${e.offsetY}px`;
            selectionBox.style.width = '0px';
            selectionBox.style.height = '0px';
            selectionBox.style.display = 'block';
            parseSelectionBtn.disabled = true;
        }

        function handleSelectionMove(e) {
            if (!indexParserState.isSelecting) return;
            const currentX = e.offsetX;
            const currentY = e.offsetY;

            const x = Math.min(currentX, indexParserState.selectionStart.x);
            const y = Math.min(currentY, indexParserState.selectionStart.y);
            const width = Math.abs(currentX - indexParserState.selectionStart.x);
            const height = Math.abs(currentY - indexParserState.selectionStart.y);

            selectionBox.style.left = `${x}px`;
            selectionBox.style.top = `${y}px`;
            selectionBox.style.width = `${width}px`;
            selectionBox.style.height = `${height}px`;
        }

        function handleSelectionEnd(e) {
            indexParserState.isSelecting = false;
            const finalWidth = parseFloat(selectionBox.style.width);
            const finalHeight = parseFloat(selectionBox.style.height);
            if (finalWidth > 5 && finalHeight > 5) {
                parseSelectionBtn.disabled = false;
            } else {
                selectionBox.style.display = 'none';
            }
        }

        function getCurrentScale() {
            if (indexParserState.currentScale !== 'auto') {
                return indexParserState.currentScale;
            }
            const page = indexParserState.currentRenderedPage;
            if (!page) return 1.0; 
            const wrapperWidth = indexCanvasWrapper.clientWidth - 40;
            const unscaledViewport = page.getViewport({ scale: 1.0 });
            return wrapperWidth / unscaledViewport.width;
        }

        function handleZoomIn() {
            const currentScale = getCurrentScale();
            indexParserState.currentScale = currentScale + 0.25;
            renderIndexPage(indexParserState.currentPageNum);
        }

        function handleZoomOut() {
            const currentScale = getCurrentScale();
            indexParserState.currentScale = Math.max(0.1, currentScale - 0.25);
            renderIndexPage(indexParserState.currentPageNum);
        }

        function handleZoomFit() {
            indexParserState.currentScale = 'auto';
            renderIndexPage(indexParserState.currentPageNum);
        }
        
        async function findIndexPages(terms, pageToExclude) {
            if (!currentPdf || terms.length === 0) {
                return [];
            }

            const foundIndexData = [];
            // The key is the original term. The value is an array of cleaned words.
            // e.g., "A0.1 COVER" -> ['a0.1', 'cover']
            const termsToFind = new Map(
                terms.map(term => {
                    const cleanedWords = term.toLowerCase().match(/[\w.]+/g) || [];
                    return [term, cleanedWords];
                })
            );

            for (let i = 1; i <= currentPdf.numPages; i++) {
                if (i === pageToExclude) {
                    continue;
                }

                if (termsToFind.size === 0) {
                    break;
                }

                setLoading(true, `Scanning for index terms on page ${i} of ${currentPdf.numPages}...`);

                const page = await currentPdf.getPage(i);
                const textContent = await page.getTextContent();
                // Join with spaces and lowercase once per page.
                const pageText = textContent.items.map(item => item.str).join(' ').toLowerCase();

                // Iterate over the map of terms we still need to find.
                for (const [originalTerm, searchWords] of termsToFind.entries()) {
                    if (searchWords.length === 0) {
                        termsToFind.delete(originalTerm); // Remove empty terms
                        continue;
                    }
                    
                    // Check if every search word is present on the page.
                    const allWordsFound = searchWords.every(word => pageText.includes(word));

                    if (allWordsFound) {
                        foundIndexData.push({ description: originalTerm, pageNum: i });
                        termsToFind.delete(originalTerm); // Remove the found term by its original key.
                    }
                }
            }

            if (termsToFind.size > 0) {
                showNotification(`${termsToFind.size} index terms could not be found in the document.`, 'error');
                console.log("Unfound terms:", [...termsToFind.keys()]);
            }

            foundIndexData.sort((a, b) => terms.indexOf(a.description) - terms.indexOf(b.description));

            return foundIndexData;
        }


        async function parseSelectedText() {
            setLoading(true, "Parsing selection...");
            try {
                const page = indexParserState.currentRenderedPage;
                const viewport = indexParserState.currentViewport;
                if (!page || !viewport) {
                    throw new Error("No page or viewport available for parsing.");
                }
                
                const pageToExclude = page.pageNumber;
                
                const rect = {
                    x: parseFloat(selectionBox.style.left),
                    y: parseFloat(selectionBox.style.top),
                    width: parseFloat(selectionBox.style.width),
                    height: parseFloat(selectionBox.style.height)
                };

                const startPoint = viewport.convertToPdfPoint(rect.x, rect.y + rect.height);
                const endPoint = viewport.convertToPdfPoint(rect.x + rect.width, rect.y);
                const pdfRect = { x1: startPoint[0], y1: startPoint[1], x2: endPoint[0], y2: endPoint[1] };

                const textContent = await page.getTextContent();
                const itemsInBox = textContent.items.filter(item => {
                    const tx = item.transform;
                    const x = tx[4];
                    const y = tx[5];
                    return x >= pdfRect.x1 && x <= pdfRect.x2 && y >= pdfRect.y1 && y <= pdfRect.y2;
                });

                itemsInBox.sort((a, b) => {
                    const y1 = a.transform[5];
                    const y2 = b.transform[5];
                    if (Math.abs(y1 - y2) > 2) { 
                        return y2 - y1;
                    }
                    return a.transform[4] - b.transform[4];
                });

                let lines = [];
                if (itemsInBox.length > 0) {
                    let currentLine = [itemsInBox[0]];
                    for (let i = 1; i < itemsInBox.length; i++) {
                        if (Math.abs(itemsInBox[i].transform[5] - itemsInBox[i-1].transform[5]) > 2) {
                            lines.push(currentLine.map(i => i.str).join(' '));
                            currentLine = [itemsInBox[i]];
                        } else {
                            currentLine.push(itemsInBox[i]);
                        }
                    }
                    lines.push(currentLine.map(i => i.str).join(' '));
                }
                
                const searchTermsFromIndex = lines.map(line => line.trim().replace(/\s+/g, ' ')).filter(line => line.length > 2);

                if (searchTermsFromIndex.length === 0) {
                    showNotification("No text found in the selection to use as search terms.", "error");
                    closeIndexParser();
                    return;
                }
                
                closeIndexParser();

                const parsedIndexData = await findIndexPages(searchTermsFromIndex, pageToExclude);

                if (parsedIndexData.length > 0) {
                    renderParsedIndex(parsedIndexData);
                    showNotification(`${parsedIndexData.length} index items found in the document.`, 'success');
                } else {
                    showNotification("Could not find any of the selected index items in the document.", "error");
                }

            } catch(error) {
                console.error("Error parsing selected text:", error);
                showNotification("Could not parse text from selection.", "error");
            } finally {
                setLoading(false);
            }
        }

        function renderParsedIndex(indexData) {
            parsedIndexOutput.innerHTML = ''; 

            if (indexData.length === 0) {
                parsedIndexOutput.innerHTML = '<p class="text-slate-500">No index data to display.</p>';
                parsedIndexContainer.classList.add('hidden');
                return;
            }

            indexData.forEach((item, index) => {
                const div = document.createElement('div');
                div.className = 'p-2 rounded-md hover:bg-slate-100 flex items-center';

                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.id = `index-item-${index}`;
                checkbox.className = 'mr-3 h-4 w-4 rounded border-gray-300 text-indigo-600 focus:ring-indigo-500';
                checkbox.dataset.pageNum = item.pageNum;

                const label = document.createElement('label');
                label.htmlFor = `index-item-${index}`;
                label.className = 'flex-grow cursor-pointer';
                label.textContent = item.description;

                const pageNumSpan = document.createElement('span');
                pageNumSpan.className = 'ml-4 font-mono text-sm text-slate-500 bg-slate-200 px-2 py-1 rounded';
                pageNumSpan.textContent = `Pg. ${item.pageNum}`;

                div.appendChild(checkbox);
                div.appendChild(label);
                div.appendChild(pageNumSpan);
                parsedIndexOutput.appendChild(div);
            });

            parsedIndexContainer.classList.remove('hidden');
        }

        async function addSelectedIndexPages() {
            const checkedBoxes = document.querySelectorAll('#parsed-index-output input[type="checkbox"]:checked');

            if (checkedBoxes.length === 0) {
                showNotification("No index items selected.", "error");
                return;
            }

            setLoading(true, "Adding selected pages...");
            const pagesToAdd = new Set(matchedPageNumbers);
            checkedBoxes.forEach(box => {
                const pageNum = parseInt(box.dataset.pageNum, 10);
                if (!isNaN(pageNum)) {
                    pagesToAdd.add(pageNum);
                }
            });

            matchedPageNumbers = Array.from(pagesToAdd).sort((a, b) => a - b);

            await rerenderAllResults();
            updateResultsSummary();
            setLoading(false);
            showNotification(`${checkedBoxes.length} page(s) added to results.`, "success");
        }


        // --- Utility Functions (UI Helpers) ---
        function setLoading(isLoading, text = "Loading...") {
            loadingText.textContent = text;
            loadingModal.classList.toggle('hidden', !isLoading);
        }

        function showNotification(message, type = 'success') {
            const notif = document.createElement('div');
            notif.className = `notification ${type}`;
            notif.textContent = message;
            notificationContainer.appendChild(notif);

            setTimeout(() => notif.classList.add('show'), 10);
            setTimeout(() => {
                notif.classList.remove('show');
                notif.addEventListener('transitionend', () => notif.remove());
            }, 3000);
        }

        function showConfirmation(message, onConfirm) {
            confirmationTitle.textContent = message;
            confirmationModal.classList.remove('hidden');

            const confirmHandler = () => {
                onConfirm();
                cleanup();
            };

            const cancelHandler = () => {
                cleanup();
            };
            
            function cleanup() {
                confirmationModal.classList.add('hidden');
                confirmBtnYes.removeEventListener('click', confirmHandler);
                confirmBtnNo.removeEventListener('click', cancelHandler);
            }

            confirmBtnYes.addEventListener('click', confirmHandler, { once: true });
            confirmBtnNo.addEventListener('click', cancelHandler, { once: true });
        }


        // --- Magnifier Functions ---
        function handleMouseLeave(event) {
            const popover = document.getElementById('magnifier-popover');
            if (popover) {
                popover.remove();
            }
        }
        
        async function handleMouseEnter(event) {
            const pageNum = parseInt(event.currentTarget.dataset.pageNumber, 10);
            if (!currentPdf || !pageNum) return;
            handleMouseLeave();
            const popover = document.createElement('div');
            popover.id = 'magnifier-popover';
            const loadingMessage = document.createElement('p');
            loadingMessage.textContent = 'Loading...';
            loadingMessage.className = 'p-4';
            popover.appendChild(loadingMessage);
            positionPopover(event, popover);
            document.body.appendChild(popover);
            const page = await currentPdf.getPage(pageNum);
            const magnifiedWidth = 500;
            const unscaledViewport = page.getViewport({ scale: 1.0 });
            const scale = magnifiedWidth / unscaledViewport.width;
            const viewport = page.getViewport({ scale: scale });
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.height = viewport.height;
            canvas.width = viewport.width;
            await page.render({ canvasContext: context, viewport: viewport }).promise;
            popover.innerHTML = '';
            popover.appendChild(canvas);
            positionPopover(event, popover);
        }
        
        function positionPopover(mouseEvent, popoverElement) {
            const popoverRect = popoverElement.getBoundingClientRect();
            const offsetX = 15;
            const offsetY = 15;
            let top = mouseEvent.clientY + offsetY;
            let left = mouseEvent.clientX + offsetX;
            if (left + popoverRect.width > window.innerWidth) {
                left = mouseEvent.clientX - popoverRect.width - offsetX;
            }
            if (top + popoverRect.height > window.innerHeight) {
                top = mouseEvent.clientY - popoverRect.height - offsetY;
            }
            popoverElement.style.top = `${top}px`;
            popoverElement.style.left = `${left}px`;
        }

        // --- Initial Application Setup ---
        function init() {
            runSearchBtn.disabled = true; 
            fileInput.addEventListener('change', handleFileSelect);

            // Drag and Drop Listeners
            dropZone.addEventListener('dragover', (e) => {
                e.preventDefault();
                e.stopPropagation();
                dropZone.classList.add('dragover');
            });

            dropZone.addEventListener('dragleave', (e) => {
                e.preventDefault();
                e.stopPropagation();
                dropZone.classList.remove('dragover');
            });

            dropZone.addEventListener('drop', (e) => {
                e.preventDefault();
                e.stopPropagation();
                dropZone.classList.remove('dragover');
                const files = e.dataTransfer.files;
                if (files.length) {
                    // This ensures other parts of the code that might reference
                    // fileInput.files (like openFilteredPdfInNewTab) will still work.
                    fileInput.files = files; 
                    loadFile(files[0]);
                }
            });
            
            // Make the whole dropzone clickable to trigger the hidden file input
            dropZone.addEventListener('click', () => {
                fileInput.click();
            });

            saveGroupBtn.addEventListener('click', saveSearchGroup);
            loadGroupBtn.addEventListener('click', loadSearchGroup);
            deleteGroupBtn.addEventListener('click', deleteSearchGroup);
            addRangeBtn.addEventListener('click', handleAddRange);
            addPageBtn.addEventListener('click', handleAddSinglePage);
            runSearchBtn.addEventListener('click', runSearch);
            openPdfBtn.addEventListener('click', openFilteredPdfInNewTab);
            addSelectedIndexBtn.addEventListener('click', addSelectedIndexPages);

            // Index Parser Event Listeners
            parseIndexBtn.addEventListener('click', openIndexParser);
            cancelIndexParserBtn.addEventListener('click', closeIndexParser);
            indexPrevPageBtn.addEventListener('click', () => changeIndexPage(-1));
            indexNextPageBtn.addEventListener('click', () => changeIndexPage(1));
            indexPageNumInput.addEventListener('change', goToIndexPage);
            parseSelectionBtn.addEventListener('click', parseSelectedText);
            zoomInBtn.addEventListener('click', handleZoomIn);
            zoomOutBtn.addEventListener('click', handleZoomOut);
            zoomFitBtn.addEventListener('click', handleZoomFit);
            
            // Selection listeners
            indexParserCanvas.parentElement.addEventListener('mousedown', handleSelectionStart);
            indexParserCanvas.parentElement.addEventListener('mousemove', handleSelectionMove);
            indexParserCanvas.parentElement.addEventListener('mouseup', handleSelectionEnd);

            initializeFirebase();
        }

        init(); 
    </script>
</body>
</html>
